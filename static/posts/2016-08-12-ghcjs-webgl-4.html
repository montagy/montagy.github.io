<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>montagy - ghcjs webgl 初探(四)</title>
    <link rel="stylesheet" type="text/css" href="../css/index.css" />
    <meta name="keywords" content="montagy blog home haskell programming" />
    <meta name="description" content="a haskell programmer's blog" />
  </head>
  <body>
    <div class="container">
      <header class="header">
  <h1 class="banner">Montagy</h1>
  <nav class="nav">
    <ul>
      <li><a href="../">主页</a></li>
      <li><a href="../static/reddit/index.html">应用</a></li>
      <li><a href="../resume.html">简历</a></li>
    </ul>
  </nav>
</header>

      <main>
        <h1>ghcjs webgl 初探(四)</h1>
        <div class="info">
    发表于: August 12, 2016
    
</div>

<p>Web上的交互主要在Dom层,我们接着上面的内容来写个触发鼠标点击的小程序.上文中我们通过attribute向着色器传输要绘制的点的坐标,然后用drawArrays来绘制, 如果我想动态的绘制这个点了?比如鼠标点一下就在鼠标点的位置绘制一个点.</p>
<p>先上代码</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">uPointSize <span class="ot">&lt;-</span> getUniformLocation gl program <span class="st">&quot;u_PointSize&quot;</span>
uniform1f gl uPointSize <span class="fl">10.0</span>
aPosition <span class="ot">&lt;-</span> getAttribLocation gl program <span class="st">&quot;a_Position&quot;</span>

points <span class="ot">&lt;-</span> newIORef []
_ <span class="ot">&lt;-</span> canvas <span class="ot">`on`</span> click <span class="fu">$&lt;/</span>span<span class="fu">&gt;</span> <span class="fu">&lt;</span>span <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;kw&quot;</span><span class="fu">&gt;</span><span class="kw">do</span><span class="fu">&lt;/</span>span<span class="fu">&gt;</span>
  (x, y) <span class="fu">&lt;</span>span <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;ot&quot;</span><span class="fu">&gt;&amp;</span>lt;<span class="fu">-&lt;/</span>span<span class="fu">&gt;</span> mouseOffsetXY
  points <span class="fu">$~</span> ((x,y) <span class="fu">:</span>)
  points' <span class="ot">&lt;-</span> get points
  clear gl <span class="dt">COLOR_BUFFER_BIT</span>
  forM_ points' <span class="fu">$</span> \(x', y') <span class="ot">-&gt;</span> <span class="kw">do</span>
    vertexAttrib3f gl (fromIntegral aPosition) ((fromIntegral x' <span class="fu">-</span> <span class="fl">200.0</span>)<span class="fu">/</span><span class="fl">200.0</span>) ((<span class="fl">200.0</span> <span class="fu">-</span> fromIntegral y')<span class="fu">/</span><span class="fl">200.0</span>) <span class="fl">0.0</span>
    drawArrays gl <span class="dt">POINTS</span> <span class="dv">0</span> <span class="dv">1</span>

clearColor gl <span class="fl">0.0</span> <span class="fl">0.0</span> <span class="fl">0.0</span> <span class="fl">1.0</span>
clear gl <span class="dt">COLOR_BUFFER_BIT</span></code></pre></div>
<p>前面三行昨天已经见过.points是个IORef值,初始化为[].IORef是一个在IO中可以改变的值,可以简单理解为IO中的变量.所以</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    points <span class="ot">&lt;-</span> newIORef []</code></pre></div>
<p>就相当于js中的 * var points = [] *.</p>
<p>我们在后面操作IORef值时用了StateVar这个包.StateVar将IO中可变数据的操作抽象为HasGetter,HasSetter,HasUpdate三个typeclass,分别表示可获取 可设置和可更新.对应的类型方法为get, $=(表示set), $~(表示update).IORef已经是他们的实例了,可以直接使用.如果自定义的数据想在IO中通过这三个方法操作 的话,可以用makeStateVar封装一下,非常方便.</p>
<p>初始化points之后就是我们今天的主题,绑定Dom事件.我们知道Dom通过addListener来绑定事件,ghcjs-dom中有同名函数.但我们一般用on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">  on ::</span> (<span class="dt">IsEventTarget</span> t, <span class="dt">IsEvent</span> e) <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">EventName</span> t e <span class="ot">-&gt;</span> <span class="dt">EventM</span> t e () <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</code></pre></div>
<p>on更强大,它创建listener,绑定事件,返回值为取消事件的函数.canvas是个Element,也是IsEventTarget的实例.click是一个事件名字(EventName),是在Element上能触发的事件. Element上能触发的事件有很多,包括keyDown,mouseDown, select等,这些可以参考<a href="https://developer.mozilla.org">MDN</a>文档.</p>
<p>EventM t e ()就是我们的回调函数,当事件触发时,它会执行,我们的绘制逻辑都在这里.</p>
<p>EventM t e ()实际是ReaderT e IO (), 它是一个Reader Monad,持有的是当前发生的事件,类比js中回调函数的参数event就可以.如果不明白ReaderT也没关系,在这里我们可以简单的 理解为回调函数有一个额外的不需要我们标明的参数event,它表示当前发生的那个事件,它还是MonadIO的实例,可以执行MonadIO,或者通过liftIO直接运行IO.</p>
<p>目光回到我们的回调函数中,是一个用do展开的表达式,这是每个haskeller每天都要面对的东西(Monad).简单的理解为按顺序执行的语句.我们通过mouseOffsetXY获得了鼠标点击处的坐标, 坐标是相对于canvas的,就是以canvas左上角为起点,向右为x轴正方形,向下为y轴正方向.1px表示1,我们宽高都是400, 所以坐标是一个(0,0)~(400,400)之间的数值对.然后我们更新points的值, 注意$~后面是更新函数,是以从points获取的值为参数,执行这个函数再存入points.第三行再取出points的值,可以用atomicModifyIORef来做这种先更新再取出来的操作, 它能够保证线程安全.我们这个单线程的程序就这么简单的用吧.</p>
<p>下面我们就要绘制了,绘制前我们先清空下颜色缓存.鼠标每点一下canvas,我们就存了一个坐标,然后把所存的坐标全部绘制出来.这个过程是对每一个坐标,我们传输值到attribute,然后drawArrays, 我用的forM_,这里用forM也是一样的,心里想着忽略返回值的时候,用forM_或者mapM_是种习惯.vertexAttrib3f的赋值与之前的一样,这里要注意的是opengl是以canvas的中心为原点的,右为 X轴正方向,上为Y轴正方向,且边界处值为1(中心到右边界为宽的1/2,中心到上边界为高的1/2).而canvas Element的坐标系是和它不一样的,这里需要做一个变换.最后我们drawArrays,就完成绘制了.</p>
<p>回调函数的返回值为取消listener的函数,我们这里没有使用就忽略了,用void忽略掉也是可以的(void $ canvas <code>on</code> click $ do ….),但个人喜欢这样写,感觉更美观,或许说不定 哪天这个函数又派上用场了,那需要改写的地方也少.最后两行是绘制的背景色,我们之前见过.因为事件是只有在触发时才会执行,所以不clear的画是看不到背景的.</p>
<h2 id="后记">后记</h2>
<p>初探就讲完了,很多函数的用法没有细讲,希望有兴趣的朋友多查文档,haddock是很方便的.之后我还会继续分享ghcjs和webgl的应用,ghcjs方面会讲到调用js中的函数(FFI)和一些包(lens,linear)的用法, webgl方面的内容可能会多一点,包括缓冲区,纹理和一些3D知识.</p>

      </main>
    </div>
    <footer class="footer">
  <div>Site proudly generated by
    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</footer>

  </body>
</html>
